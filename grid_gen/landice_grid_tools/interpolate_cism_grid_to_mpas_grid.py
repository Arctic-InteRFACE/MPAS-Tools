#!/usr/bin/env python
'''
Interpolate fields from a regular CISM grid into a pre-existing MPAS grid,
using either a built-in bilinear interpolation method or using weights
generated by ESMF.
'''

import sys
import numpy as np
import netCDF4
from optparse import OptionParser
import math
from collections import OrderedDict
import scipy.interpolate as spint
import scipy.spatial.qhull as qhull
import time


print "== Gathering information.  (Invoke with --help for more details. All arguments are optional)\n"
parser = OptionParser()
parser.description = "This script interpolates from a CISM grid to an MPAS grid using an ESMF weight interpolation file."
parser.add_option("-c", "--cism", dest="cismFile", help="CISM grid file to input.", default="cism.nc", metavar="FILENAME")
parser.add_option("-m", "--mpas", dest="mpasFile", help="MPAS grid file to output.", default="landice_grid.nc", metavar="FILENAME")
parser.add_option("-i", "--interp", dest="interpType", help="interpolation method to use. b=bilinear, d=barycentric, e=ESMF", default="b", metavar="METHOD")
parser.add_option("-w", "--weight", dest="weightFile", help="ESMF weight file to input.  Only used by ESMF interpolation method", metavar="FILENAME")
for option in parser.option_list:
    if option.default != ("NO", "DEFAULT"):
        option.help += (" " if option.help else "") + "[default: %default]"
options, args = parser.parse_args()

print "  CISM input file:  " + options.cismFile
print "  MPAS file to be modified:  " + options.mpasFile

print "  Interolation method to be used:  " + options.interpType
print "    (b=bilinear, d=barycentric, e=esmf)"

if options.weightFile and options.interpType == 'e':
    print "  Interpolation will be performed using ESMF-weights method, where possible, using weights file:  " + options.weightFile
    #----------------------------
    # Get weights from file
    wfile = netCDF4.Dataset(options.weightFile, 'r')
    S = wfile.variables['S'][:]
    col = wfile.variables['col'][:]
    row = wfile.variables['row'][:]
    wfile.close()
    #----------------------------

print '' # make a space in stdout before further output


#----------------------------
# Define which time levels you want to use in the two files! (0-based indexing in python)
timelev = 0
timelevout = 0
#----------------------------

#----------------------------
# Map MPAS-CISM field names - add new fields here as needed
fieldInfo = OrderedDict()
fieldInfo['thickness'] =     {'CISMname':'thk',  'scalefactor':1.0, 'offset':0.0, 'CISMgrid':1, 'vertDim':False}
fieldInfo['bedTopography'] = {'CISMname':'topg', 'scalefactor':1.0, 'offset':0.0, 'CISMgrid':1, 'vertDim':False}
fieldInfo['sfcMassBal'] =    {'CISMname':'acab', 'scalefactor':910.0/(3600.0*24.0*365.0), 'offset':0.0, 'CISMgrid':1, 'vertDim':False}  # Assuming default CISM density
#fieldInfo['temperature'] =   {'CISMname':'temp', 'scalefactor':1.0, 'offset':273.15, 'CISMgrid':1, 'vertDim':True}
fieldInfo['temperature'] =   {'CISMname':'tempstag', 'scalefactor':1.0, 'offset':273.15, 'CISMgrid':1, 'vertDim':True}  # pick one or the other
fieldInfo['beta'] =          {'CISMname':'beta', 'scalefactor':1.0, 'offset':0.0, 'CISMgrid':0, 'vertDim':False} # needs different mapping file...
#fieldInfo['observedSpeed'] = {'CISMname':'balvel', 'scalefactor':1.0/(365.0*24.0*3600.0), 'offset':0.0, 'CISMgrid':0, 'vertDim':False} # needs different mapping file...


#----------------------------

#----------------------------
#----------------------------
# Define needed functions
#----------------------------
#----------------------------

def ESMF_interp(sourceField):
    # Interpolates from the sourceField to the destinationField using ESMF weights
  try:
    # Initialize new field to 0 - required
    destinationField = np.zeros(xCell.shape)  # fields on cells only
    sourceFieldFlat = sourceField.flatten()  # Flatten source field
    for i in range(len(row)):
      destinationField[row[i]-1] = destinationField[row[i]-1] + S[i] * sourceFieldFlat[col[i]]
  except:
     'error in ESMF_interp'
  return destinationField

#----------------------------

def BilinearInterp(Value, CISMgridType):
    # Calculate bilinear interpolation of Value field from x, y to new ValueCell field (return value)  at xCell, yCell
    # This assumes that x, y, Value are regular CISM style grids and xCell, yCell, ValueCell are 1-D unstructured MPAS style grids
  try:
    if CISMgridType == 0:
        x = x0; y = y0
    elif CISMgridType == 1:
        x = x1; y = y1
    else:
        sys.exit('Error: unknown CISM grid type specified.')
    dx = x[1] - x[0]
    dy = y[1] - y[0]
    ValueCell = np.zeros(xCell.shape)
    for i in range(len(xCell)):
       # Calculate the CISM grid cell indices (these are the lower index)
       xgrid = math.floor( (xCell[i]-x[0]) / dx )
       if xgrid >= len(x) - 1:
          xgrid = len(x) - 2
       elif xgrid < 0:
          xgrid = 0
       ygrid = math.floor( (yCell[i]-y[0]) / dy )
       if ygrid >= len(y) - 1:
          ygrid = len(y) - 2
       elif ygrid < 0:
          ygrid = 0
       #print xgrid, ygrid
       ValueCell[i] = Value[ygrid,xgrid] * (x[xgrid+1] - xCell[i]) * (y[ygrid+1] - yCell[i]) / (dx * dy) + \
                 Value[ygrid+1,xgrid] * (x[xgrid+1] - xCell[i]) * (yCell[i] - y[ygrid]) / (dx * dy) + \
                 Value[ygrid,xgrid+1] * (xCell[i] - x[xgrid]) * (y[ygrid+1] - yCell[i]) / (dx * dy) + \
                 Value[ygrid+1,xgrid+1] * (xCell[i] - x[xgrid]) * (yCell[i] - y[ygrid]) / (dx * dy) 
  except:
     'error in BilinearInterp'
  return ValueCell

#----------------------------

def delaunay_interp_weights(xy, uv, d=2):
    tri = qhull.Delaunay(xy)
    print "    Delaunay triangulation complete."
    simplex = tri.find_simplex(uv)
    print "    find_simplex complete."
    vertices = np.take(tri.simplices, simplex, axis=0)
    print "    identified vertices."
    temp = np.take(tri.transform, simplex, axis=0)
    print "    np.take complete."
    delta = uv - temp[:, d]
    bary = np.einsum('njk,nk->nj', temp[:, :d, :], delta)
    print "    calculating bary complete."
    return vertices, np.hstack((bary, 1 - bary.sum(axis=1, keepdims=True)))

#----------------------------

def delaunay_interpolate(values, CISMgridType):
    if CISMgridType == 0:
       vtx = vtx0; wts = wts0
    elif CISMgridType == 1:
       vtx = vtx1; wts = wts1
    else:
        sys.exit('Error: unknown CISM grid type specified.')

    return np.einsum('nj,nj->n', np.take(values, vtx), wts)

#----------------------------

def interpolate_field(MPASfieldName):

    if fieldInfo[MPASfieldName]['CISMgrid'] == 0 and options.interpType == 'e':
       assert "This CISM field is on the staggered grid, and currently this script does not support a second ESMF weight file for the staggered grid."

    CISMfieldName = fieldInfo[MPASfieldName]['CISMname']
    if 'time' in CISMfile.variables[CISMfieldName].dimensions:
        CISMfield = CISMfile.variables[CISMfieldName][timelev,:,:]
    else:
        CISMfield = CISMfile.variables[CISMfieldName][:,:]

    print '  CISM %s min/max:'%CISMfieldName, CISMfield.min(), CISMfield.max()

    # Call the appropriate routine for actually doing the interpolation
    if options.interpType == 'b':
        print "  ...Interpolating to %s using built-in bilinear method..." % MPASfieldName
        MPASfield = BilinearInterp(CISMfield, fieldInfo[MPASfieldName]['CISMgrid'])
    elif options.interpType == 'd':
        print "  ...Interpolating to %s using barycentric method..." % MPASfieldName
        MPASfield = delaunay_interpolate(CISMfield, fieldInfo[MPASfieldName]['CISMgrid'])
    elif options.interpType == 'e':
        print "  ...Interpolating to %s using ESMF-weights method..." % MPASfieldName
        MPASfield = ESMF_interp(CISMfield)
    else:
        sys.exit('ERROR: Unknown interpolation method specified')

    print '  interpolated MPAS %s min/max:'%MPASfieldName, MPASfield.min(), MPASfield.max()

    if fieldInfo[MPASfieldName]['scalefactor'] != 1.0:
        MPASfield *= fieldInfo[MPASfieldName]['scalefactor']
        print '  scaled MPAS %s min/max:'%MPASfieldName, MPASfield.min(), MPASfield.max()
    if fieldInfo[MPASfieldName]['offset'] != 0.0:
        MPASfield += fieldInfo[MPASfieldName]['offset']
        print '  offset MPAS %s min/max:'%MPASfieldName, MPASfield.min(), MPASfield.max()


    return MPASfield

    del CISMfield, MPASfield

#----------------------------

def interpolate_field_with_layers(MPASfieldName):

    if fieldInfo[MPASfieldName]['CISMgrid'] == 0 and options.interpType == 'e':
       assert "This CISM field is on the staggered grid, and currently this script does not support a second ESMF weight file for the staggered grid."

    CISMfieldName = fieldInfo[MPASfieldName]['CISMname']
    if 'time' in CISMfile.variables[CISMfieldName].dimensions:
        CISMfield = CISMfile.variables[CISMfieldName][timelev,:,:]
    else:
        CISMfield = CISMfile.variables[CISMfieldName][:,:]

    # create array for interpolated CISM field at all layers
    cismVerticalDimSize = CISMfield.shape[0] # vertical index is the first (since we've eliminated time already)
    mpas_grid_cism_layers = np.zeros( (cismVerticalDimSize, nCells) ) # make it the size of the CISM vertical layers, but the MPAS horizontal layers

    for z in range(cismVerticalDimSize):
        print '  CISM layer %s, layer %s min/max:'%(z,CISMfieldName), CISMfield[z,:,:].min(), CISMfield[z,:,:].max()
        # Call the appropriate routine for actually doing the interpolation
        if options.interpType == 'b':
            print "  ...Layer %s, Interpolating this layer to MPAS grid using built-in bilinear method..." % (z)
            mpas_grid_cism_layers[z,:] = BilinearInterp(CISMfield[z,:,:], fieldInfo[MPASfieldName]['CISMgrid'])
        elif options.interpType == 'd':
            print "  ...Layer %s, Interpolating this layer to MPAS grid using built-in barycentric method..." % (z)
            mpas_grid_cism_layers[z,:] = delaunay_interpolate(CISMfield[z,:,:], fieldInfo[MPASfieldName]['CISMgrid'])
        elif options.interpType == 'e':
            print "  ...Layer %s, Interpolating this layer to MPAS grid using ESMF-weights method..." % (z)
            mpas_grid_cism_layers[z,:] = ESMF_interp(CISMfield[z,:,:])
        else:
            sys.exit('ERROR: Unknown interpolation method specified')
        print '  interpolated MPAS %s, layer %s min/max:'%(MPASfieldName, z), mpas_grid_cism_layers[z,:].min(), mpas_grid_cism_layers[z,:].max()

    if fieldInfo[MPASfieldName]['scalefactor'] != 1.0:
        mpas_grid_cism_layers *= fieldInfo[MPASfieldName]['scalefactor']
        print '  scaled MPAS %s on CISM vertical layers, min/max:'%MPASfieldName, MPASfield.min(), MPASfield.max()
    if fieldInfo[MPASfieldName]['offset'] != 0.0:
        MPASfield += fieldInfo[MPASfieldName]['offset']
        print '  offset MPAS %s min/max:'%MPASfieldName, MPASfield.min(), MPASfield.max()

    # ------------
    # Now interpolate vertically
    cism_layers = CISMfile.variables[CISMfile.variables[CISMfieldName].dimensions[1]][:]  # 2nd dimension is the vertical one - get it's name and then get the variable that has the same name
    print "  CISM layer field {} has layers: {}".format(CISMfile.variables[CISMfieldName].dimensions[1], cism_layers)
    MPASfield = vertical_interp_MPAS_grid(mpas_grid_cism_layers, cism_layers)
    print '  MPAS %s on MPAS vertical layers, min/max of all layers:'%MPASfieldName, MPASfield.min(), MPASfield.max()

    del mpas_grid_cism_layers

    return MPASfield


#----------------------------

def vertical_interp_MPAS_grid(mpas_grid_cism_layers, cism_layers):
    destinationField = np.zeros((nCells, nVertLevels))
    for i in range(nCells):
        destinationField[i,:] = np.interp(mpasLayerCenters, cism_layers, mpas_grid_cism_layers[:,i])
    return destinationField


#----------------------------
#----------------------------




print "=================="
print 'Gathering coordinate information from CISM and MPAS files.'


# Open the input file, get needed dimensions
try:
    CISMfile = netCDF4.Dataset(options.cismFile,'r')

    # Get the CISM dimensions if they exist
    try:
      level = len(CISMfile.dimensions['level'])
    except:
      print '  Input file is missing the dimension level.  Might not be a problem.'

    try:
      stagwbndlevel = len(CISMfile.dimensions['stagwbndlevel'])
    except:
      print '  Input file is missing the dimension stagwbndlevel.  Might not be a problem.'

    # Get CISM location variables if they exist
    try:
      x1 = CISMfile.variables['x1'][:]
      dx1 = x1[1] - x1[0]
      #print 'x1 min/max/dx:', x1.min(), x1.max(), dx1
      y1 = CISMfile.variables['y1'][:]
      dy1 = y1[1] - y1[0]
      #print 'y1 min/max/dx:', y1.min(), y1.max(), dy1

      ##x1 = x1 - (x1.max()-x1.min())/2.0  # This was for some shifted CISM grid but should not be used in general.
      ##y1 = y1 - (y1.max()-y1.min())/2.0
    except:
      print '  Input file is missing x1 and/or y1.  Might not be a problem.'
    
    try:
      x0 = CISMfile.variables['x0'][:]
      #print 'x0 min/max:', x0.min(), x0.max()
      y0 = CISMfile.variables['y0'][:]
      #print 'y0 min/max:', y0.min(), y0.max()

      ##x0 = x0 - (x0.max()-x0.min())/2.0
      ##y0 = y0 - (y0.max()-y0.min())/2.0

    except:
      print '  Input file is missing x0 and/or y0.  Might not be a problem.'

except:
    sys.exit('Error: The input file specified is either missing or lacking needed dimensions/variables.')



# Open the output file, get needed dimensions & variables
try:
    MPASfile = netCDF4.Dataset(options.mpasFile,'r+')
    try:
      nVertLevels = len(MPASfile.dimensions['nVertLevels'])
    except:
      print 'Output file is missing the dimension nVertLevels.  Might not be a problem.'

    try:
      # 1d vertical fields
      layerThicknessFractions = MPASfile.variables['layerThicknessFractions'][:]
      # build up sigma levels
      mpasLayerCenters = np.zeros( (nVertLevels,) )
      mpasLayerCenters[0] = 0.5 * layerThicknessFractions[0]
      for k in range(nVertLevels)[1:]:  # skip the first level
          mpasLayerCenters[k] = mpasLayerCenters[k-1] + 0.5 * layerThicknessFractions[k-1] + 0.5 * layerThicknessFractions[k]
      print "  Using MPAS layer centers at sigma levels: {}".format(mpasLayerCenters)
    except:
      print 'Output file is missing the variable layerThicknessFractions.  Might not be a problem.'

    # '2d' spatial fields on cell centers
    xCell = MPASfile.variables['xCell'][:]
    #print 'xCell min/max:', xCell.min(), xCell.max()
    yCell = MPASfile.variables['yCell'][:]
    #print 'yCell min/max:', yCell.min(), yCell.max()
    nCells = len(MPASfile.dimensions['nCells'])

except:
    sys.exit('Error: The output grid file specified is either missing or lacking needed dimensions/variables.')
print "==================\n"

# Check the overlap of the grids
print '=================='
print 'CISM File extents:'
print '  x1 min, max:    ', x1.min(), x1.max()
print '  y1 min, max:    ', y1.min(), y1.max()
print 'MPAS File extents:'
print '  xCell min, max: ', xCell.min(), xCell.max()
print '  yCell min, max: ', yCell.min(), yCell.max()
print '=================='


#----------------------------
# Setup Delaunay/barycentric interpolation weights if needed
if options.interpType == 'd':
   mpasXY = np.vstack((xCell[:], yCell[:])).transpose()

   [Yi,Xi] = np.meshgrid(x1[:], y1[:])
   cismXY1 = np.zeros([Xi.shape[0]*Xi.shape[1],2])
   cismXY1[:,0] = Yi.flatten()
   cismXY1[:,1] = Xi.flatten()

   print '\nBuilding interpolation weights: CISM x1/y1 -> MPAS'
   start = time.clock()
   vtx1, wts1 = delaunay_interp_weights(cismXY1, mpasXY)
   end = time.clock(); print 'done in ', end-start

   if 'x0' in CISMfile.variables:
     # Need to setup separate weights for this grid
      [Yi,Xi] = np.meshgrid(x0[:], y0[:])
      cismXY0 = np.zeros([Xi.shape[0]*Xi.shape[1],2])
      cismXY0[:,0] = Yi.flatten()
      cismXY0[:,1] = Xi.flatten()

      print 'Building interpolation weights: CISM x0/y0 -> MPAS'
      start = time.clock()
      vtx0, wts0 = delaunay_interp_weights(cismXY0, mpasXY)
      end = time.clock(); print 'done in ', end-start



#----------------------------
# try each field.  If it exists in the input file, it will be copied.  If not, it will be skipped.
for MPASfieldName in fieldInfo:
  try:
    print '\n## %s ##'%MPASfieldName


    start = time.clock()
    if fieldInfo[MPASfieldName]['vertDim']:
      MPASfield = interpolate_field_with_layers(MPASfieldName)
    else:
      MPASfield = interpolate_field(MPASfieldName)
    end = time.clock(); print '  interpolation done in ', end-start

    # Don't allow negative thickness.
    if MPASfieldName == 'thickness' and MPASfield.min() < 0.0:
        MPASfield[MPASfield < 0.0] = 0.0
        print '  removed negative thickness, new min/max:'%MPASfieldName, MPASfield.min(), MPASfield.max()

    # Now insert the MPAS field into the file.
    if 'Time' in MPASfile.variables[MPASfieldName].dimensions:
        MPASfile.variables[MPASfieldName][timelevout,:] = MPASfield  # Time will always be leftmost index
    else:
        MPASfile.variables[MPASfieldName][:] = MPASfield

    MPASfile.sync()  # update the file now in case we get an error later

  except:
    print '  problem with %s field (e.g. not found in input file), skipping...'%MPASfieldName

# Update history attribute of netCDF file
if hasattr(MPASfile, 'history'):
   newhist = '\n'.join([getattr(MPASfile, 'history'), ' '.join(sys.argv[:]) ] )
else:
   newhist = sys.argv[:]
setattr(MPASfile, 'history', newhist )

CISMfile.close()
MPASfile.close()

print '\nInterpolation completed.'
